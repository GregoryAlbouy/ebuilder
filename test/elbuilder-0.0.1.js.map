{"version":3,"sources":["webpack://ElBuilder/webpack/bootstrap","webpack://ElBuilder/./src/Check.ts","webpack://ElBuilder/./src/ElementBuilder.ts","webpack://ElBuilder/./src/ElementBuilderAnimation.ts","webpack://ElBuilder/./src/ElementBuilderError.ts","webpack://ElBuilder/./src/Parse.ts","webpack://ElBuilder/./src/Rule.ts","webpack://ElBuilder/./src/Setter.ts","webpack://ElBuilder/./src/index.ts"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEa;AACb,8CAA8C,cAAc;AAC5D,kCAAkC,mBAAO,CAAC,mEAA2B;AACrE,8BAA8B,mBAAO,CAAC,2DAAuB;AAC7D,cAAc,mBAAO,CAAC,+BAAS;AAC/B,cAAc,mBAAO,CAAC,+BAAS;AAC/B,eAAe,mBAAO,CAAC,iCAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B,EAAE;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sCAAsC,qBAAqB,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT,uCAAuC;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnMa;AACb,8CAA8C,cAAc;AAC5D,8BAA8B,mBAAO,CAAC,2DAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E,yCAAyC,SAAS,MAAM,SAAS;AACjE,yCAAyC,UAAU,MAAM,UAAU;AACnE;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,MAAM,uBAAuB;AAC5F,6CAA6C,mBAAmB,MAAM,wBAAwB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU,IAAI,aAAa;AACnD;AACA;AACA;;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,+BAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS,4BAA4B,IAAI,aAAa;AACtD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEa;AACb,8CAA8C,cAAc;AAC5D;AACA,8BAA8B,mBAAO,CAAC,2DAAuB;AAC7D,cAAc,mBAAO,CAAC,+BAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AC1Da;AACb,8CAA8C,cAAc;AAC5D;AACA,8BAA8B,mBAAO,CAAC,2DAAuB;AAC7D,cAAc,mBAAO,CAAC,+BAAS;AAC/B,cAAc,mBAAO,CAAC,+BAAS;AAC/B,aAAa,mBAAO,CAAC,6BAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ha;AACb,iBAAiB,mBAAO,CAAC,oDAAqB","file":"elbuilder-0.0.1.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\n/* Type checks */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNamedFunction = exports.hasName = exports.isValidTarget = exports.isValidSwap = exports.isValidSource = exports.isValidChild = exports.isElementBuilder = exports.isElement = exports.isEventTupleArray = exports.isEventTuple = exports.isStringObject = exports.isArrayArray = exports.isArray = exports.isFunction = exports.isNumber = exports.isTypeOf = exports.typeOf = void 0;\nexports.typeOf = (s) => {\n    return `${{}.toString.call(s)}`\n        .replace(/^\\[object ([a-z]+)\\]$/i, '$1')\n        .toLowerCase();\n};\nexports.isTypeOf = (x, ...types) => {\n    return types\n        .map((type) => exports.typeOf(x) === type.toLocaleLowerCase())\n        .reduce((a, c) => a || c);\n};\nexports.isNumber = (subject) => {\n    return exports.isTypeOf(subject, 'number');\n};\nexports.isFunction = (subject) => {\n    return exports.isTypeOf(subject, 'function');\n};\nexports.isArray = (subject) => {\n    return exports.isTypeOf(subject, 'array');\n};\nexports.isArrayArray = (subject) => {\n    return (exports.isTypeOf(subject, 'array')\n        && subject.every((item) => exports.isTypeOf(item, 'array')));\n};\nexports.isStringObject = (subject) => {\n    return (exports.isTypeOf(subject, 'object')\n        && Object.keys(subject).every((item) => exports.isTypeOf(item, 'string')));\n};\nexports.isEventTuple = (subject) => {\n    return (exports.isTypeOf(subject, 'array')\n        && exports.isTypeOf(subject[0], 'string')\n        && exports.isTypeOf(subject[1], 'function')\n        && (!subject[2] || exports.isTypeOf(subject[2], 'boolean', 'object')));\n};\nexports.isEventTupleArray = (subject) => {\n    return (exports.isTypeOf(subject, 'array')\n        && subject.every(exports.isEventTuple));\n};\nexports.isElement = (subject) => {\n    return subject instanceof Element;\n};\nexports.isElementBuilder = (subject) => {\n    return (subject instanceof Object\n        && 'isElementBuilder' in subject && 'el' in subject\n        && subject.isElementBuilder && subject.el);\n};\nexports.isValidChild = (child) => {\n    return (exports.isTypeOf(child, 'string', 'number')\n        || child instanceof Node\n        || child.isElementBuilder);\n};\nexports.isValidSource = (source) => {\n    return (source instanceof Element || exports.isTypeOf(source, 'string'));\n};\nexports.isValidSwap = (element, swapped) => {\n    return (element instanceof HTMLElement && swapped instanceof HTMLElement\n        && (!!element.parentNode && !!swapped.parentNode)\n        && element !== swapped);\n};\nexports.isValidTarget = (target) => {\n    return exports.isElementBuilder(target) || target instanceof Element;\n};\nexports.hasName = (input) => {\n    return !!input.name;\n};\nexports.isNamedFunction = (input) => {\n    return exports.isFunction(input) && exports.hasName(input);\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ElementBuilderAnimation_1 = require(\"./ElementBuilderAnimation\");\nconst ElementBuilderError_1 = require(\"./ElementBuilderError\");\nconst Check = require(\"./Check\");\nconst Parse = require(\"./Parse\");\nconst Setter = require(\"./Setter\");\nconst ElementBuilder = function (source) {\n    if (!Check.isValidSource(source)) {\n        new ElementBuilderError_1.default('Invalid source input', source);\n        return;\n    }\n    const element = Setter.element(source);\n    const referenceMap = new Map([['window', window]]);\n    return {\n        el: element,\n        element: element,\n        htmlContent: function () { return this.element.innerHTML; },\n        isElementBuilder: true,\n        referenceMap: referenceMap,\n        getRef: function (query) {\n            return this.referenceMap.get(query) || (new ElementBuilderError_1.default('nul!', query), false);\n        },\n        given: function (...references) {\n            const register = (ref) => {\n                if (Check.isArray(ref)) {\n                    const [target, id] = ref;\n                    this.referenceMap.set(id, target);\n                }\n                else if (Check.isNamedFunction(ref)) {\n                    this.referenceMap.set(ref.name, ref);\n                }\n                else\n                    new ElementBuilderError_1.default('Invalid given() argument input', ref);\n            };\n            references.forEach(register);\n            return this;\n        },\n        into: function (targetInput, { at = -1, times = 1 } = {}) {\n            if (!Check.isValidTarget(targetInput))\n                return;\n            const getTarget = (target) => {\n                return Check.isElementBuilder(target)\n                    ? target.element\n                    : target;\n            };\n            const insertAt = (element, target, n) => {\n                if (!Check.isNumber(n))\n                    return;\n                const getPos = (n, length) => {\n                    return n < 0\n                        ? Math.max(length - 1 + n, 0)\n                        : Math.min(length - 1, n);\n                };\n                const childList = target.children;\n                const p = getPos(n, childList.length);\n                if (childList.length === 0 || childList.length - 1 === p)\n                    target.appendChild(element);\n                else\n                    childList[p].insertAdjacentElement('beforebegin', element);\n            };\n            const target = getTarget(targetInput);\n            const p = Math.floor(Number(at));\n            Number.isNaN(p) ? target.appendChild(element) : insertAt(element, target, p);\n            // if (!Check.isNumber(times) || times < 1) {\n            //     new ElementBuilderError('Invalid times value (whole number >= 1 expected)', times)\n            // }\n            // else if (times === 1) {\n            //     target.appendChild(element)\n            // }\n            // /**\n            //  * FIX: elements appended but settings not applied\n            //  */\n            // else {\n            //     console.log(times)\n            //     const clone = () => element.cloneNode(true)\n            //     ;[...Array(Math.floor(times))].forEach(() => target.appendChild(clone()))\n            // }\n            this.element.dispatchEvent(new CustomEvent('ElementBuilderInsert'));\n            return this;\n        },\n        after: function (node) {\n            node.insertAdjacentElement('afterend', element);\n            this.element.dispatchEvent(new CustomEvent('ElementBuilderInsert'));\n            return this;\n        },\n        before: function (node) {\n            node.insertAdjacentElement('beforebegin', element);\n            this.element.dispatchEvent(new CustomEvent('ElementBuilderInsert'));\n            return this;\n        },\n        replace: function (node) {\n            var _a;\n            (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(element, node);\n            this.element.dispatchEvent(new CustomEvent('ElementBuilderInsert'));\n            return this;\n        },\n        swap: async function (swapped, animate) {\n            if (!Check.isValidSwap(element, swapped))\n                return;\n            if (animate) {\n                const ms = typeof animate === 'object' && animate.animationDuration\n                    ? animate.animationDuration\n                    : undefined;\n                await new ElementBuilderAnimation_1.default(ms).swap2(element, swapped);\n            }\n            const dummy = document.createElement('div');\n            element.parentNode.replaceChild(dummy, element);\n            swapped.parentNode.replaceChild(element, swapped);\n            dummy.parentNode.replaceChild(swapped, dummy);\n            return this;\n        },\n        out: function () {\n            var _a;\n            (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n        },\n        dispatch: function (nameInput, emitterInput) {\n            const emitter = !emitterInput\n                ? this.element\n                : 'isElementBuilder' in emitterInput\n                    ? emitterInput.element\n                    : emitterInput;\n            emitter.dispatchEvent(new CustomEvent(nameInput));\n            console.log(emitter, nameInput);\n            return this;\n        },\n        set: function (options = {}) {\n            const Options = {\n                properties: Setter.Properties,\n                attributes: Setter.Attributes,\n                listeners: Setter.Listeners,\n                children: Setter.Children,\n            };\n            const setOption = (name, value) => {\n                if (!(name in Options))\n                    return;\n                Options[name].call(this, value);\n            };\n            Setter.process.call(this, options, setOption);\n            this.element.dispatchEvent(new CustomEvent('elbuilderset'));\n            return this;\n        },\n        setAttributes: function (attributes) {\n            Setter.Attributes.call(this, attributes);\n            return this;\n        },\n        setProperties: function (properties) {\n            Setter.Properties.call(this, properties);\n            return this;\n        },\n        setListeners: function (listeners) {\n            Setter.Listeners.call(this, listeners);\n            return this;\n        },\n        setChildren: function (children) {\n            Setter.Children.call(this, children);\n            return this;\n        },\n        setStyles: function (styles) {\n            const value = Parse.getComputedValue.call(this, styles);\n            Setter.Styles.call(this, value);\n            return this;\n        },\n        // todo: (classes: string | array | object)\n        // object: { add, remove, toggle }\n        // setClasses: (classes: string[] | string, ...args: string[]) => {\n        //     typeOf(classes) === 'array' ? element.classList.add(...classes)\n        //                                 : element.classList.add(classes)\n        //     return this\n        // },\n        setClasses: function (...classes) {\n            element.classList.add(...[].concat(...classes));\n            return this;\n        },\n        setStyle: function (styles = {}) {\n            if (element instanceof HTMLElement) {\n                Object.assign(element.style, styles);\n            }\n            return this;\n        },\n        textContent: function (input) {\n            element.textContent = input;\n            return this;\n        },\n        toString: function () {\n            return element.outerHTML;\n        },\n        /**\n         * TODO: add filter parameter\n         */\n        count: function () {\n            return this.element.childNodes.length;\n        }\n    };\n};\nexports.default = ElementBuilder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ElementBuilderError_1 = require(\"./ElementBuilderError\");\nclass ElementBuilderAnimation {\n    constructor(duration) {\n        this.duration = 200;\n        this.then = {\n            then: (resolve) => setTimeout(resolve, this.duration)\n        };\n        if (duration && duration < 0)\n            throw new ElementBuilderError_1.default('Invalid animation duration', name);\n        else\n            this.duration = duration || this.duration;\n    }\n    /*\n     * Using css transitions\n     */\n    swap(a, b) {\n        const offset = {\n            h: b.getBoundingClientRect().left - a.getBoundingClientRect().left,\n            v: b.getBoundingClientRect().top - a.getBoundingClientRect().top\n        };\n        [a, b].map((elt) => elt.style.transition = `transform ${this.duration}ms`);\n        a.style.transform = `translate(${offset.h}px, ${offset.v}px)`;\n        b.style.transform = `translate(${-offset.h}px, ${-offset.v}px)`;\n        setTimeout(() => {\n            [a, b].forEach((elt) => {\n                elt.style.transform = '';\n                elt.style.transition = '';\n            });\n        }, this.duration);\n    }\n    swap2(a, b) {\n        const dist = {\n            x: b.getBoundingClientRect().left - a.getBoundingClientRect().left,\n            y: b.getBoundingClientRect().top - a.getBoundingClientRect().top\n        };\n        const vOffsetMax = a.getBoundingClientRect().height / 2;\n        const step = (timestamp) => {\n            progress = (timestamp - start) / this.duration;\n            if (progress > 1)\n                progress = 1;\n            dy = progress <= .5 ? vOffsetMax * progress * 2 : vOffsetMax * (1 - progress) * 2;\n            a.style.transform = `translate(${dist.x * progress}px, ${dist.y * progress + dy}px)`;\n            b.style.transform = `translate(${-dist.x * progress}px, ${-dist.y * progress - dy}px)`;\n            progress < 1 ? requestAnimationFrame(step) : end();\n        };\n        const end = () => {\n            [a, b].forEach((elt) => elt.style.transform = '');\n        };\n        let dy = 0, progress = 0, start = performance.now();\n        requestAnimationFrame(step);\n        return this.then;\n    }\n}\nexports.default = ElementBuilderAnimation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ElementBuilderError extends Error {\n    constructor(message, suspect) {\n        super(message);\n        this.name = 'ElementBuilderError';\n        this.suspect = suspect;\n        console.warn(`${this.name}: ${this.message}:\\n`, this.suspect, '\\n');\n    }\n}\nexports.default = ElementBuilderError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sourceObject = exports.getComputedValue = exports.eventInput = exports.elementStringSource = void 0;\nconst Check = require(\"./Check\");\nfunction elementStringSource(source) {\n    const Rrule = /^@(\\w+):/;\n    const Rvalue = /:(.+)?/;\n    const ruleMatch = source.match(Rrule);\n    const valueMatch = source.match(Rvalue);\n    const safeMatch = (match) => match ? match[1] : '';\n    return {\n        rule: safeMatch(ruleMatch),\n        value: safeMatch(valueMatch)\n    };\n}\nexports.elementStringSource = elementStringSource;\nfunction eventInput(eventInput) {\n    const elementFrom = (getRefResult) => {\n        return 'isElementBuilder' in getRefResult ? getRefResult.element : getRefResult;\n    };\n    const [type, targetInput] = eventInput.split('#');\n    const target = targetInput ? elementFrom(this.getRef(targetInput)) : this.element;\n    return [type, target];\n}\nexports.eventInput = eventInput;\nfunction getComputedValue(value) {\n    return Check.isFunction(value) ? value.call(this) : value;\n}\nexports.getComputedValue = getComputedValue;\nexports.sourceObject = (source) => {\n    // 'properties@once:click@interval:1000' => ['properties', 'once:click', 'interval:1000']\n    const parseSourceKey = (sourceKey) => sourceKey.split('@');\n    // 'once:click' => ['once', 'click']\n    const parseRawRule = (rawRule) => rawRule.split(':');\n    const getProcessedEntriesFromSource = (source) => {\n        return Object.keys(source).map((sourceKey) => {\n            // trueKey = 'properties', rawRules = ['once:click', 'interval:1000']\n            const [trueKey, ...rawRules] = parseSourceKey(sourceKey);\n            const ruleMap = new Map(rawRules.map(parseRawRule));\n            return {\n                key: trueKey,\n                value: source[sourceKey],\n                rules: ruleMap\n            };\n        });\n    };\n    const getObjectFromEntries = (processedEntries) => {\n        const object = Object.create(null);\n        processedEntries.forEach((entry) => {\n            Object.defineProperty(object, entry.key, {\n                enumerable: true,\n                value: {\n                    value: entry.value,\n                    rules: entry.rules,\n                    hasRules: function () { return !!this.rules.size; }\n                }\n            });\n        });\n        return object;\n    };\n    // [{ key: 'attributes', value: {...}, rules: [] }, ...], \n    const processedEntries = getProcessedEntriesFromSource(source);\n    const finalObject = getObjectFromEntries(processedEntries);\n    // const finalMap = createMapFromProcessedEntries(processedEntries)\n    return finalObject;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.For = exports.If = exports.Timeout = exports.Interval = exports.Once = exports.On = exports.RuleMap = void 0;\nconst ElementBuilderError_1 = require(\"./ElementBuilderError\");\nconst Parse = require(\"./Parse\");\nexports.RuleMap = {\n    on: On,\n    once: Once,\n    interval: Interval,\n    timeout: Timeout,\n    if: If,\n    for: For\n};\nfunction handleEvent(eventInput, callback, isOnce) {\n    const [type, emitter] = Parse.eventInput.call(this, eventInput);\n    const once = () => {\n        emitter.removeEventListener(type, once);\n        callback();\n    };\n    const handler = isOnce ? once : callback;\n    if ('addEventListener' in emitter)\n        emitter.addEventListener(type, handler);\n}\nfunction On(eventInput, callback) {\n    handleEvent.call(this, eventInput, callback);\n}\nexports.On = On;\nfunction Once(eventInput, callback) {\n    handleEvent.call(this, eventInput, callback, true);\n}\nexports.Once = Once;\nfunction Interval(rate, callback) {\n    this.interval = setInterval(callback, parseInt(rate));\n}\nexports.Interval = Interval;\nfunction Timeout(delay, callback) {\n    setTimeout(callback, parseInt(delay));\n}\nexports.Timeout = Timeout;\nfunction If(conditionId, callback) {\n    if (!this.referenceMap.has(conditionId)) {\n        new ElementBuilderError_1.default(`Condition id not found. Make sure to provide the corresponding pair [Function: boolean, conditionId: string] as an argument of the .given() method before using an @if rule `, conditionId);\n    }\n    else if (this.referenceMap.get(conditionId)()) {\n        callback();\n    }\n}\nexports.If = If;\nfunction For(conditionId, callback) {\n    const array = this.getRef(conditionId);\n    console.log(array, conditionId);\n    array.forEach((v, i, a) => {\n        // TODO: find a way to get the (function) value of an entry with @for rule\n        // const realValue = entryValue.bind.call(this, v, i a)\n        console.log(callback);\n        callback();\n    });\n}\nexports.For = For;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.process = exports.Children = exports.Listeners = exports.Styles = exports.Attributes = exports.Properties = exports.element = void 0;\nconst ElementBuilderError_1 = require(\"./ElementBuilderError\");\nconst Check = require(\"./Check\");\nconst Parse = require(\"./Parse\");\nconst Rule = require(\"./Rule\");\nfunction element(source) {\n    const hasRule = (input) => input.charAt(0) === '@';\n    const inputType = (input) => /^<.*>$/.test(input) ? 'html' : 'element';\n    const getElementFromHTML = (value) => {\n        const template = document.createElement('template');\n        template.innerHTML = value;\n        return template.content.firstElementChild;\n    };\n    const ruleMap = {\n        'html': (value) => getElementFromHTML(value),\n        'select': (value) => document.querySelector(value),\n        'element': (value) => document.createElement(value)\n    };\n    if (source instanceof Element)\n        return source;\n    if (hasRule(source)) {\n        const { rule, value } = Parse.elementStringSource(source);\n        if (!value)\n            new ElementBuilderError_1.default('Invalid ElBuilder source input', source);\n        const safeRule = rule !== null && rule !== void 0 ? rule : 'element';\n        return ruleMap[safeRule](value);\n    }\n    return ruleMap[inputType(source)](source);\n}\nexports.element = element;\nfunction Properties(properties = {}) {\n    const setProperty = (name, value) => {\n        this.element[name] = value;\n    };\n    process.call(this, properties, setProperty);\n}\nexports.Properties = Properties;\nfunction Attributes(attributes = {}) {\n    const addAttribute = (name, value) => {\n        if (this.element instanceof Element) {\n            this.element.setAttribute(name, value);\n        }\n    };\n    process.call(this, attributes, addAttribute);\n}\nexports.Attributes = Attributes;\nfunction Styles(styles = {}) {\n    const setStyle = (name, value) => {\n        if (this.element instanceof HTMLElement) {\n            this.element.style[name] = value;\n        }\n    };\n    process.call(this, styles, setStyle);\n}\nexports.Styles = Styles;\nfunction Listeners(listeners) {\n    const addListener = ([event, listener, options]) => {\n        this.element.addEventListener(event, listener, options);\n    };\n    if (Check.isEventTuple(listeners))\n        addListener(listeners);\n    else if (Check.isEventTupleArray(listeners))\n        listeners.forEach(addListener);\n    else\n        new ElementBuilderError_1.default('Invalid input for listeners input ([string, Function] or [string, Function][] expected)', listeners);\n}\nexports.Listeners = Listeners;\nfunction Children(children) {\n    const addChild = (child) => {\n        if (!Check.isValidChild(child)) {\n            new ElementBuilderError_1.default('Invalid child (Node, string, number or ElementBuilder instance expected)', child);\n            return;\n        }\n        if (child instanceof Node) {\n            this.element.appendChild(child);\n        }\n        else if (Check.isTypeOf(child, 'string', 'number')) {\n            this.element.innerHTML += `${child}`;\n        }\n        else if (child.isElementBuilder) {\n            this.element.appendChild(child.element);\n        }\n        else\n            new ElementBuilderError_1.default(`Invalid input in children array`, child);\n    };\n    const childrenValue = Parse.getComputedValue.call(this, children);\n    Check.isValidChild(childrenValue)\n        ? addChild(childrenValue)\n        : Check.isTypeOf(childrenValue, 'array')\n            ? childrenValue.forEach(addChild)\n            : new ElementBuilderError_1.default(`Invalid input for children value`, childrenValue);\n}\nexports.Children = Children;\nfunction process(source, callback, keyRestriction) {\n    const parsedObject = Parse.sourceObject(source);\n    const processEntry = (key) => {\n        if (keyRestriction && !(key in keyRestriction))\n            return;\n        const currentEntry = parsedObject[key];\n        const { value, rules } = currentEntry;\n        /**\n         * Possible entry point for calling additionnal parameters for, e.g., @-for rule\n         */\n        const computedValue = () => Parse.getComputedValue.call(this, value);\n        const setEntry = () => callback(key, computedValue());\n        currentEntry.hasRules() ? submitToRules(rules, setEntry) : setEntry();\n    };\n    const submitToRules = (rules, callback) => {\n        let ruleApplied = false;\n        const applyRule = (ruleValue, ruleName) => {\n            const ruleKey = ruleName.toLowerCase();\n            if (ruleKey in Rule.RuleMap) {\n                Rule.RuleMap[ruleKey].call(this, ruleValue, callback);\n                ruleApplied = true;\n            }\n        };\n        rules.forEach(applyRule);\n        if (!ruleApplied)\n            callback();\n    };\n    Object.keys(parsedObject).forEach(processEntry);\n}\nexports.process = process;\n","\"use strict\";\nmodule.exports = require('./ElementBuilder.ts').default;\n"],"sourceRoot":""}