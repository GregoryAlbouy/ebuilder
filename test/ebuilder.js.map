{"version":3,"sources":["webpack://EBuilder/webpack/bootstrap","webpack://EBuilder/./src/index.ts","webpack://EBuilder/./src/modules/EBuilder.ts","webpack://EBuilder/./src/modules/EBuilderAnimation.ts","webpack://EBuilder/./src/modules/EBuilderError.ts","webpack://EBuilder/./src/modules/Rule.ts","webpack://EBuilder/./src/utils/Check.ts","webpack://EBuilder/./src/utils/DOM.ts","webpack://EBuilder/./src/utils/Parse.ts","webpack://EBuilder/./src/utils/Setter.ts"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,iBAAiB,mBAAO,CAAC,qDAAoB;;;;;;;;;;;;;ACDhC;AACb,8CAA8C,cAAc;AAC5D,4BAA4B,mBAAO,CAAC,+DAAqB;AACzD,wBAAwB,mBAAO,CAAC,uDAAiB;AACjD,cAAc,mBAAO,CAAC,4CAAgB;AACtC,YAAY,mBAAO,CAAC,wCAAc;AAClC,cAAc,mBAAO,CAAC,4CAAgB;AACtC,eAAe,mBAAO,CAAC,8CAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sCAAsC,qBAAqB,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+CAA+C,QAAQ,2FAA2F,EAAE;AACpJ;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,mCAAmC,kBAAkB;AACrD;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzKa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,uDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E,yCAAyC,SAAS,MAAM,SAAS;AACjE,yCAAyC,UAAU,MAAM,UAAU;AACnE;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,MAAM,uBAAuB;AAC5F,6CAA6C,mBAAmB,MAAM,wBAAwB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU,IAAI,aAAa;AACnD;AACA;AACA;;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA,wBAAwB,mBAAO,CAAC,uDAAiB;AACjD,cAAc,mBAAO,CAAC,4CAAgB;AACtC,cAAc,mBAAO,CAAC,4CAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;AClEa;AACb;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEa;AACb,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,qCAAS;AAC/B,cAAc,mBAAO,CAAC,qCAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B,6BAA6B,cAAc;AAC3C,4BAA4B,iBAAiB;AAC7C,kBAAkB,GAAG;AACrB,wBAAwB,EAAE;AAC1B,4BAA4B,EAAE;AAC9B,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFa;AACb,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,qCAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS,4BAA4B,IAAI,aAAa;AACtD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrGa;AACb,8CAA8C,cAAc;AAC5D;AACA,wBAAwB,mBAAO,CAAC,gEAA0B;AAC1D,cAAc,mBAAO,CAAC,qCAAS;AAC/B,cAAc,mBAAO,CAAC,qCAAS;AAC/B,aAAa,mBAAO,CAAC,8CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ebuilder.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\nmodule.exports = require('./modules/EBuilder').default;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EBuilderAnimation_1 = require(\"./EBuilderAnimation\");\nconst EBuilderError_1 = require(\"./EBuilderError\");\nconst Check = require(\"../utils/Check\");\nconst DOM = require(\"../utils/DOM\");\nconst Parse = require(\"../utils/Parse\");\nconst Setter = require(\"../utils/Setter\");\nconst EBuilder = function (source) {\n    if (!Check.isValidSource(source)) {\n        new EBuilderError_1.default('Invalid source input', source);\n        return;\n    }\n    const element = Setter.element(source);\n    const referenceMap = new Map([['window', window]]);\n    const cloneList = [];\n    return {\n        el: element,\n        element: element,\n        getHTML: function () { return this.element.innerHTML; },\n        isEBuilder: true,\n        referenceMap: referenceMap,\n        cloneList: cloneList,\n        getRef: function (query) {\n            return query ? this.referenceMap.get(query) : (new EBuilderError_1.default('nul!', query), false);\n        },\n        given: function (...references) {\n            const register = (ref) => {\n                if (Check.isArray(ref)) {\n                    const [target, id] = ref; // come back here later\n                    this.referenceMap.set(id, target);\n                }\n                else if (Check.isNamedFunction(ref)) {\n                    this.referenceMap.set(ref.name, ref);\n                }\n                else\n                    new EBuilderError_1.default('Invalid given() argument input', ref);\n            };\n            references.forEach(register);\n            return this;\n        },\n        into: function (targetInput, { at = -1, times = 1 } = {}) {\n            if (!Check.isValidTarget(targetInput) || !Check.isNumber(times))\n                return;\n            // use Parse.getTrueElement() instead\n            const getTarget = (target) => {\n                return Check.isEBObject(target)\n                    ? target.element\n                    : target;\n            };\n            DOM.insertV1.call(this, this.element, getTarget(targetInput), at, times);\n            this.element.dispatchEvent(new CustomEvent('ebuilderinsert'));\n            return this;\n        },\n        after: function (inputTarget) {\n            const target = Parse.getTrueElement(inputTarget);\n            target.insertAdjacentElement('afterend', element);\n            this.element.dispatchEvent(new CustomEvent('ebuilderinsert'));\n            return this;\n        },\n        before: function (inputTarget) {\n            const target = Parse.getTrueElement(inputTarget);\n            target.insertAdjacentElement('beforebegin', element);\n            this.element.dispatchEvent(new CustomEvent('ebuilderinsert'));\n            return this;\n        },\n        replace: function (inputTarget) {\n            var _a;\n            const target = Parse.getTrueElement(inputTarget);\n            (_a = target.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(element, target);\n            this.element.dispatchEvent(new CustomEvent('ebuilderinsert'));\n            return this;\n        },\n        swap: async function (swapped, animate) {\n            if (!Check.isValidSwap(element, swapped))\n                return;\n            if (animate) {\n                const ms = typeof animate === 'object' && animate.animationDuration\n                    ? animate.animationDuration\n                    : undefined;\n                await new EBuilderAnimation_1.default(ms).swap2(element, swapped);\n            }\n            const dummy = document.createElement('div');\n            element.parentNode.replaceChild(dummy, element);\n            swapped.parentNode.replaceChild(element, swapped);\n            dummy.parentNode.replaceChild(swapped, dummy);\n            return this;\n        },\n        out: function (all) {\n            var _a;\n            (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n            if (all)\n                this.clearClones;\n            return this;\n        },\n        clearClones: function () {\n            this.cloneList.forEach((clone) => { var _a; return (_a = clone.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(clone); });\n            return this;\n        },\n        dispatch: function (nameInput, emitterInput) {\n            const emitter = !emitterInput\n                ? this.element\n                : 'isEBuilder' in emitterInput\n                    ? emitterInput.element\n                    : emitterInput;\n            emitter.dispatchEvent(new CustomEvent(nameInput));\n            console.log(emitter, nameInput);\n            return this;\n        },\n        set: function (options = {}) {\n            const Options = {\n                properties: Setter.Properties,\n                attributes: Setter.Attributes,\n                listeners: Setter.Listeners,\n                children: Setter.Children,\n                style: Setter.Style\n            };\n            const setOption = (name, value) => {\n                if (!(name in Options))\n                    return;\n                Options[name].call(this, value);\n            };\n            Setter.process.call(this, options, setOption);\n            this.element.dispatchEvent(new CustomEvent('ebuilderset'));\n            return this;\n        },\n        setAttributes: function (attributes) {\n            Setter.Attributes.call(this, attributes);\n            return this;\n        },\n        setProperties: function (properties) {\n            Setter.Properties.call(this, properties);\n            return this;\n        },\n        setListeners: function (listeners) {\n            Setter.Listeners.call(this, listeners);\n            return this;\n        },\n        setChildren: function (children) {\n            Setter.Children.call(this, children);\n            return this;\n        },\n        setStyle: function (style) {\n            // const value = Parse.getComputedValue.call(this, style)\n            Setter.Style.call(this, style);\n            return this;\n        },\n        setClasses: function (...classes) {\n            element.classList.add(...[].concat(...classes));\n            return this;\n        },\n        // + setContent(options = { add?, remove?,  })\n        setContent: function (input) {\n            this.element.innerHTML = `${input}`;\n            // DOM.insert.call(this, input, element, at, 1)\n            return this;\n        },\n        toString: function () {\n            return element.outerHTML;\n        },\n        count: function () {\n            return this.element.childNodes.length;\n        },\n        setElement: function (value) {\n            this.element = value;\n            this.el = value;\n        }\n    };\n};\nexports.default = EBuilder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EBuilderError_1 = require(\"./EBuilderError\");\nclass EBuilderAnimation {\n    constructor(duration) {\n        this.duration = 200;\n        this.then = {\n            then: (resolve) => setTimeout(resolve, this.duration)\n        };\n        if (duration && duration < 0)\n            throw new EBuilderError_1.default('Invalid animation duration', name);\n        else\n            this.duration = duration || this.duration;\n    }\n    /*\n     * Using css transitions\n     */\n    swap(a, b) {\n        const offset = {\n            h: b.getBoundingClientRect().left - a.getBoundingClientRect().left,\n            v: b.getBoundingClientRect().top - a.getBoundingClientRect().top\n        };\n        [a, b].map((elt) => elt.style.transition = `transform ${this.duration}ms`);\n        a.style.transform = `translate(${offset.h}px, ${offset.v}px)`;\n        b.style.transform = `translate(${-offset.h}px, ${-offset.v}px)`;\n        setTimeout(() => {\n            [a, b].forEach((elt) => {\n                elt.style.transform = '';\n                elt.style.transition = '';\n            });\n        }, this.duration);\n    }\n    swap2(a, b) {\n        const dist = {\n            x: b.getBoundingClientRect().left - a.getBoundingClientRect().left,\n            y: b.getBoundingClientRect().top - a.getBoundingClientRect().top\n        };\n        const vOffsetMax = a.getBoundingClientRect().height / 2;\n        const step = (timestamp) => {\n            progress = (timestamp - start) / this.duration;\n            if (progress > 1)\n                progress = 1;\n            dy = progress <= .5 ? vOffsetMax * progress * 2 : vOffsetMax * (1 - progress) * 2;\n            a.style.transform = `translate(${dist.x * progress}px, ${dist.y * progress + dy}px)`;\n            b.style.transform = `translate(${-dist.x * progress}px, ${-dist.y * progress - dy}px)`;\n            progress < 1 ? requestAnimationFrame(step) : end();\n        };\n        const end = () => {\n            [a, b].forEach((elt) => elt.style.transform = '');\n        };\n        let dy = 0, progress = 0, start = performance.now();\n        requestAnimationFrame(step);\n        return this.then;\n    }\n}\nexports.default = EBuilderAnimation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EBuilderError extends Error {\n    constructor(message, suspect) {\n        super(message);\n        this.name = 'EBuilderError';\n        this.suspect = suspect;\n        console.warn(`${this.name}: ${this.message}:\\n`, this.suspect, '\\n');\n    }\n}\nexports.default = EBuilderError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.For2 = exports.For = exports.If = exports.Timeout = exports.Interval = exports.Once = exports.On = exports.RuleMap = void 0;\nconst EBuilderError_1 = require(\"./EBuilderError\");\nconst Check = require(\"../utils/Check\");\nconst Parse = require(\"../utils/Parse\");\nexports.RuleMap = {\n    on: On,\n    once: Once,\n    interval: Interval,\n    timeout: Timeout,\n    if: If,\n    for: For\n};\nfunction handleEvent(eventInput, callback, isOnce) {\n    const [type, emitter] = Parse.eventInput.call(this, eventInput);\n    const once = () => {\n        emitter.removeEventListener(type, once);\n        callback();\n    };\n    const handler = isOnce ? once : callback;\n    if ('addEventListener' in emitter)\n        emitter.addEventListener(type, handler);\n}\nfunction On(eventInput, callback) {\n    handleEvent.call(this, eventInput, callback);\n}\nexports.On = On;\nfunction Once(eventInput, callback) {\n    handleEvent.call(this, eventInput, callback, true);\n}\nexports.Once = Once;\nfunction Interval(rate, callback) {\n    this.interval = setInterval(callback, parseInt(rate));\n}\nexports.Interval = Interval;\nfunction Timeout(delay, callback) {\n    setTimeout(callback, parseInt(delay));\n}\nexports.Timeout = Timeout;\nfunction If(conditionId, callback) {\n    if (!this.referenceMap.has(conditionId)) {\n        new EBuilderError_1.default(`Condition id not found. Make sure to provide the corresponding pair [Function: boolean, conditionId: string] as an argument of the .given() method before using an @if rule `, conditionId);\n    }\n    else if (this.referenceMap.get(conditionId)()) {\n        callback();\n    }\n}\nexports.If = If;\nfunction For(conditionId, callback) {\n    const array = this.getRef(conditionId);\n    console.log(array, conditionId);\n    array.forEach((v, i, a) => {\n        // TODO: find a way to get the (function) value of an entry with @for rule\n        // const realValue = entryValue.bind.call(this, v, i a)\n        console.log(callback);\n        callback();\n    });\n}\nexports.For = For;\nfunction For2(ref, callback) {\n    if (!Check.isArray(ref))\n        return callback.call(this), void ref.forEach((v, i, a) => {\n            callback.call(this, v, i, a);\n        });\n}\nexports.For2 = For2;\n","\"use strict\";\n/* Type checks */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNamedFunction = exports.hasName = exports.isValidTarget = exports.isValidSwap = exports.isValidSource = exports.isValidChild = exports.isEBObject = exports.isElement = exports.isEventTupleArray = exports.isEventTuple = exports.isStringObject = exports.isArrayArray = exports.isArray = exports.isFunction = exports.isString = exports.isNumber = exports.isTypeOf = exports.typeOf = void 0;\nexports.typeOf = (input) => {\n    return `${{}.toString.call(input)}`\n        .replace(/^\\[object ([a-z]+)\\]$/i, '$1')\n        .toLowerCase();\n};\nexports.isTypeOf = (input, ...types) => {\n    return types\n        .map((type) => exports.typeOf(input) === type.toLocaleLowerCase())\n        .reduce((a, c) => a || c);\n};\nexports.isNumber = (input) => {\n    return exports.isTypeOf(input, 'number');\n};\nexports.isString = (input) => {\n    return exports.isTypeOf(input, 'string');\n};\nexports.isFunction = (input) => {\n    return exports.isTypeOf(input, 'function');\n};\nexports.isArray = (input) => {\n    return exports.isTypeOf(input, 'array');\n};\nexports.isArrayArray = (input) => {\n    return (exports.isTypeOf(input, 'array')\n        && input.every((item) => exports.isTypeOf(item, 'array')));\n};\nexports.isStringObject = (input) => {\n    return (exports.isTypeOf(input, 'object')\n        && Object.keys(input).every((item) => exports.isTypeOf(item, 'string')));\n};\nexports.isEventTuple = (input) => {\n    return (exports.isTypeOf(input, 'array')\n        && exports.isTypeOf(input[0], 'string')\n        && exports.isTypeOf(input[1], 'function')\n        && (!input[2] || exports.isTypeOf(input[2], 'boolean', 'object')));\n};\nexports.isEventTupleArray = (input) => {\n    return (exports.isTypeOf(input, 'array')\n        && input.every(exports.isEventTuple));\n};\nexports.isElement = (input) => {\n    return input instanceof Element;\n};\nexports.isEBObject = (input) => {\n    return (input instanceof Object\n        && input.isEBuilder);\n};\nexports.isValidChild = (input) => {\n    return (exports.isTypeOf(input, 'string', 'number')\n        || input instanceof Node\n        || input.isEBuilder);\n};\nexports.isValidSource = (source) => {\n    return (source instanceof Element || exports.isTypeOf(source, 'string'));\n};\nexports.isValidSwap = (element, swapped) => {\n    return (element instanceof HTMLElement && swapped instanceof HTMLElement\n        && (!!element.parentNode && !!swapped.parentNode)\n        && element !== swapped);\n};\nexports.isValidTarget = (target) => {\n    return exports.isEBObject(target) || target instanceof Element;\n};\nexports.hasName = (input) => {\n    return !!input.name;\n};\nexports.isNamedFunction = (input) => {\n    return exports.isFunction(input) && exports.hasName(input);\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.insertV1 = exports.insert = void 0;\nconst Check = require(\"./Check\");\nconst Parse = require(\"./Parse\");\n/**\n * In progress\n */\nfunction insert(input, target, at, times) {\n    const posFromString = (at, childList) => {\n        const posMap = {\n            start: 0,\n            middle: Math.floor(childList.length / 2),\n            end: childList.length\n        };\n        return at in posMap ? posMap[at] : posMap.end;\n    };\n    const safePos = (n, length) => {\n        return n < 0\n            ? Math.max(length + (n + 1), 0)\n            : Math.min(length, n);\n    };\n    const safeTimes = times ? Math.abs(Math.floor(times)) : 1;\n    const computedInput = Parse.getComputedValue.call(this, input);\n    const fragment = Parse.getFragmentFrom(computedInput, safeTimes);\n    const childList = target.children;\n    const n = Check.isString(at) ? posFromString(at, childList) : Math.floor(at);\n    const p = safePos(n, childList.length);\n    // console.log(\n    //     `input: ${input}\\n`,\n    //     `computedInput: ${computedInput}\\n`,\n    //     `targetLength: ${childList.length}\\n`,\n    //     `at: ${at}\\n`,\n    //     `position: ${n}\\n`,\n    //     `safePosition: ${p}\\n`,\n    //     `times: ${times}\\n`,\n    //     `fragment:`, fragment\n    // )\n    // console.log(fragment.firstElementChild)\n    this.setElement(fragment.firstElementChild); // needs checks\n    if (childList.length === 0 || childList.length === p) {\n        // console.log('cas 1')\n        target.appendChild(fragment);\n    }\n    else {\n        // console.log(childList[p], p)\n        target.insertBefore(fragment, childList[p]);\n    }\n    // console.log(input)\n    // console.log(fragment.firstChild)\n}\nexports.insert = insert;\nfunction insertV1(input, target, at, times) {\n    const posFromString = (at, childList) => {\n        const posMap = {\n            start: 0,\n            middle: Math.floor(childList.length / 2),\n            end: childList.length\n        };\n        return at in posMap ? posMap[at] : posMap.end;\n    };\n    const safePos = (n, length) => {\n        return n < 0\n            ? Math.max(length + (n + 1), 0)\n            : Math.min(length, n);\n    };\n    let safeTimes = times ? Math.abs(Math.floor(times)) : 1;\n    const clones = [...Array(safeTimes - 1)].map(() => input.cloneNode(true));\n    const childList = target.children;\n    const n = Check.isString(at) ? posFromString(at, childList) : Math.floor(at);\n    const p = safePos(n, childList.length);\n    this.cloneList.push(...clones);\n    // needs refacto\n    if (childList.length === 0 || childList.length === p) {\n        target.appendChild(input);\n        clones.forEach((clone) => target.appendChild(clone));\n    }\n    else {\n        const childRef = childList[p];\n        target.insertBefore(input, childRef);\n        clones.forEach((clone) => target.insertBefore(clone, childRef));\n    }\n}\nexports.insertV1 = insertV1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.inputObject = exports.getComputedValue2 = exports.getComputedValue = exports.getTrueElement = exports.eventInput = exports.getElementFrom = exports.getFragmentFrom = exports.HTMLToElement = exports.elementStringSource = void 0;\nconst Check = require(\"./Check\");\nfunction elementStringSource(source) {\n    const Rrule = /^@(\\w+):/;\n    const Rvalue = /:(.+)?/;\n    const ruleMatch = source.match(Rrule);\n    const valueMatch = source.match(Rvalue);\n    const safeMatch = (match) => match ? match[1] : '';\n    return {\n        rule: safeMatch(ruleMatch),\n        value: safeMatch(valueMatch)\n    };\n}\nexports.elementStringSource = elementStringSource;\nfunction HTMLToElement(html) {\n    const template = document.createElement('template');\n    template.innerHTML = html;\n    return template.content.firstChild; // needs checks\n}\nexports.HTMLToElement = HTMLToElement;\nfunction getFragmentFrom(input, times = 1) {\n    const template = document.createElement('template');\n    let safeTimes = Math.abs(Math.floor(times));\n    const fillTemplate = (input) => {\n        const html = Check.isElement(input) ? input.outerHTML : `${input}`;\n        template.innerHTML += html;\n    };\n    while (safeTimes--)\n        fillTemplate(input);\n    return template.content;\n}\nexports.getFragmentFrom = getFragmentFrom;\nfunction getElementFrom(input) {\n    return (Check.isString(input)\n        ? HTMLToElement(input) // change this\n        : Check.isEBObject(input)\n            ? input.element\n            : input // needs checks\n    );\n}\nexports.getElementFrom = getElementFrom;\nfunction eventInput(eventInput) {\n    // replace with getTrueElement()\n    const elementFrom = (getRefResult) => {\n        return 'isEBuilder' in getRefResult ? getRefResult.element : getRefResult;\n    };\n    const [type, targetInput] = eventInput.split('#');\n    const target = targetInput ? elementFrom(this.getRef(targetInput)) : this.element;\n    return [type, target];\n}\nexports.eventInput = eventInput;\nfunction getTrueElement(input) {\n    return Check.isEBObject(input) ? input.element : input;\n}\nexports.getTrueElement = getTrueElement;\nfunction getComputedValue(value) {\n    return Check.isFunction(value) ? value.call(this) : value;\n}\nexports.getComputedValue = getComputedValue;\nfunction getComputedValue2(value, boundData) {\n    return Check.isFunction(value) ? value.call(this, boundData) : value;\n}\nexports.getComputedValue2 = getComputedValue2;\nexports.inputObject = (source) => {\n    // 'properties@once:click@interval:1000' => ['properties', 'once:click', 'interval:1000']\n    const parseSourceKey = (sourceKey) => sourceKey.split('@');\n    // 'once:click' => ['once', 'click']\n    const parseRawRule = (rawRule) => rawRule.split(':');\n    const parseEntries = (source) => {\n        return Object.keys(source).map((sourceKey) => {\n            // trueKey = 'properties', rawRules = ['once:click', 'interval:1000']\n            const [trueKey, ...rawRules] = parseSourceKey(sourceKey);\n            const ruleMap = new Map(rawRules.map(parseRawRule));\n            return {\n                key: trueKey,\n                value: source[sourceKey],\n                rules: ruleMap\n            };\n        });\n    };\n    const getObjectFromEntries = (processedEntries) => {\n        const object = Object.create(null);\n        processedEntries.forEach((entry) => {\n            Object.defineProperty(object, entry.key, {\n                enumerable: true,\n                value: {\n                    value: entry.value,\n                    rules: entry.rules,\n                    hasRules: function () { return !!this.rules.size; }\n                }\n            });\n        });\n        return object;\n    };\n    // [{ key: 'attributes', value: {...}, rules: [] }, ...], \n    const processedEntries = parseEntries(source);\n    const finalObject = getObjectFromEntries(processedEntries);\n    // const finalMap = createMapFromProcessedEntries(processedEntries)\n    return finalObject;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.process2 = exports.process = exports.Children = exports.Listeners = exports.Style = exports.Attributes = exports.Properties = exports.element = void 0;\nconst EBuilderError_1 = require(\"../modules/EBuilderError\");\nconst Check = require(\"./Check\");\nconst Parse = require(\"./Parse\");\nconst Rule = require(\"../modules/Rule\");\n/**\n * Determinate the source element to work on depending on the input:\n * element => element\n * 'div' or '@element:div' => div element\n * '<div>hello</div> or '@html:<div>hello</div> => element built upon html\n * '@select:div.mydiv' => document.querySelector('div.mydiv')\n */\nfunction element(source) {\n    const hasRule = (input) => input.charAt(0) === '@';\n    const inputType = (input) => /^<.*>$/.test(input) ? 'html' : 'element';\n    const getElementFromHTML = (html) => {\n        const template = document.createElement('template');\n        template.innerHTML = html;\n        return template.content.firstElementChild;\n    };\n    const ruleMap = {\n        'html': (value) => getElementFromHTML(value),\n        'select': (value) => document.querySelector(value),\n        'element': (value) => document.createElement(value)\n    };\n    if (Check.isElement(source))\n        return source;\n    if (Check.isEBObject(source))\n        return source.element;\n    source = `${source}`;\n    if (hasRule(source)) {\n        const { rule, value } = Parse.elementStringSource(source);\n        if (!value)\n            new EBuilderError_1.default('Invalid ElBuilder source input', source);\n        const safeRule = rule !== null && rule !== void 0 ? rule : 'element';\n        return ruleMap[safeRule](value);\n    }\n    return ruleMap[inputType(source)](source);\n}\nexports.element = element;\nfunction Properties(properties = {}) {\n    const setProperty = (name, value) => {\n        this.element[name] = value;\n    };\n    process.call(this, properties, setProperty);\n}\nexports.Properties = Properties;\nfunction Attributes(attributes = {}) {\n    const addAttribute = (name, value) => {\n        if (this.element instanceof Element) {\n            this.element.setAttribute(name, value);\n        }\n    };\n    process.call(this, attributes, addAttribute);\n}\nexports.Attributes = Attributes;\nfunction Style(style = {}) {\n    const setStyle = (name, value) => {\n        if (this.element instanceof HTMLElement) {\n            this.element.style[name] = value;\n        }\n    };\n    process.call(this, style, setStyle);\n}\nexports.Style = Style;\nfunction Listeners(listeners) {\n    const addListener = ([event, listener, options]) => {\n        this.element.addEventListener(event, listener, options);\n    };\n    if (Check.isEventTuple(listeners))\n        addListener(listeners);\n    else if (Check.isEventTupleArray(listeners))\n        (listeners).forEach(addListener);\n    else\n        new EBuilderError_1.default('Invalid input for listeners input ([string, Function] or [string, Function][] expected)', listeners);\n}\nexports.Listeners = Listeners;\nfunction Children(children) {\n    const addChild = (child) => {\n        if (!Check.isValidChild(child)) {\n            new EBuilderError_1.default('Invalid child (Node, string, number or EBuilder instance expected)', child);\n            return;\n        }\n        if (child instanceof Node) {\n            this.element.appendChild(child);\n        }\n        else if (Check.isTypeOf(child, 'string', 'number')) {\n            this.element.innerHTML += `${child}`;\n        }\n        else if (Check.isEBObject(child)) {\n            this.element.appendChild((child).element);\n        }\n        else\n            new EBuilderError_1.default(`Invalid input in children array`, child);\n    };\n    const childrenValue = Parse.getComputedValue.call(this, children);\n    Check.isValidChild(childrenValue)\n        ? addChild(childrenValue)\n        : Check.isTypeOf(childrenValue, 'array')\n            ? (childrenValue).forEach(addChild)\n            : new EBuilderError_1.default(`Invalid input for children value`, childrenValue);\n}\nexports.Children = Children;\nfunction process(source, callback, keyRestriction) {\n    const parsedObject = Parse.inputObject(source);\n    const processEntry = (key) => {\n        if (keyRestriction && !(key in keyRestriction))\n            return;\n        const currentEntry = parsedObject[key];\n        const { value, rules } = currentEntry;\n        const computedValue = () => Parse.getComputedValue.call(this, value);\n        const setEntry = () => callback(key, computedValue());\n        currentEntry.hasRules() ? submitToRules(rules, setEntry) : setEntry();\n    };\n    const submitToRules = (rules, callback) => {\n        let ruleApplied = false;\n        const applyRule = (ruleValue, ruleName) => {\n            const ruleKey = ruleName.toLowerCase();\n            if (ruleKey in Rule.RuleMap) {\n                Rule.RuleMap[ruleKey].call(this, ruleValue, callback);\n                ruleApplied = true;\n            }\n        };\n        rules.forEach(applyRule);\n        if (!ruleApplied)\n            callback();\n    };\n    Object.keys(parsedObject).forEach(processEntry);\n}\nexports.process = process;\nfunction process2(source, callback, keyRestriction) {\n    const parsedObject = Parse.inputObject(source);\n    const processEntry = (key) => {\n        if (keyRestriction && !(key in keyRestriction))\n            return;\n        const currentEntry = parsedObject[key];\n        const { value, rules } = currentEntry;\n        if (rules.has('for')) {\n            if (Check.isFunction(value)) {\n                const ref = this.getRef(rules.get('for')); // needs checks\n                Rule.For2.call(this, ref, value);\n            }\n        }\n        else {\n            const computedValue = () => Parse.getComputedValue.call(this, value);\n            const setEntry = () => callback(key, computedValue());\n            // const computedValue2 = (boundData?: any[]) => Parse.getComputedValue2.call(this, value, boundData)\n            // const setEntry2 = (boundData?: any[]) => callback(key, computedValue2(boundData))\n            currentEntry.hasRules() ? submitToRules(rules, setEntry) : setEntry();\n        }\n    };\n    const submitToRules = (rules, callback) => {\n        let ruleApplied = false;\n        const applyRule = (ruleValue, ruleName) => {\n            const ruleKey = ruleName.toLowerCase();\n            if (ruleKey in Rule.RuleMap) {\n                Rule.RuleMap[ruleKey].call(this, ruleValue, callback);\n                ruleApplied = true;\n            }\n        };\n        const applyRule2 = (ruleValue, ruleName) => {\n            const ruleKey = ruleName.toLowerCase();\n            if (ruleKey in Rule.RuleMap) {\n                Rule.RuleMap[ruleKey].call(this, ruleValue, callback);\n                ruleApplied = true;\n            }\n        };\n        rules.forEach(applyRule);\n        if (!ruleApplied)\n            callback();\n    };\n    Object.keys(parsedObject).forEach(processEntry);\n}\nexports.process2 = process2;\n"],"sourceRoot":""}